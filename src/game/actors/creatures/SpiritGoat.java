package game.actors.creatures;

import edu.monash.fit2099.engine.actions.Action;
import edu.monash.fit2099.engine.actions.ActionList;
import edu.monash.fit2099.engine.actions.DoNothingAction;
import edu.monash.fit2099.engine.actors.Actor;
import edu.monash.fit2099.engine.displays.Display;
import edu.monash.fit2099.engine.items.Item;
import edu.monash.fit2099.engine.positions.Exit;
import edu.monash.fit2099.engine.positions.GameMap;
import edu.monash.fit2099.engine.positions.Location;
import game.behaviours.ProduceBehaviour;
import game.behaviours.WanderBehaviour;
import game.behaviours.behaviourselectors.BehaviourSelector;
import game.capabilities.GeneralCapability;
import game.conditions.Condition;
import game.conditions.NearbyCapabilityCondition;
import game.healing.Curable;
import game.healing.CureAction;
import game.weapons.actions.AttackAction;

/**
 * Represents a Spirit Goat monster in the game. Spirit Goats wander the map using
 * {@link WanderBehaviour} and can be attacked by actors possessing the
 * {@link GeneralCapability#HOSTILE_TO_ENEMY} capability. They are afflicted by Crimson Rot from the
 * start, managed internally via the {@link Rotatable} interface, causing them to become unconscious
 * after a set number of turns ({@value #INITIAL_ROT_COUNTDOWN}). Spirit Goats can be cured using
 * items with the {@link GeneralCapability#CAN_CURED} capability via the {@link CureAction}. Curing
 * a Spirit Goat resets its internal rot timer back to the initial value. Spirit Goats can also
 * produce new Spirit Goats when near a {@link GeneralCapability#BLESSED} entity. This class
 * implements {@link Curable}, {@link Rotatable}, and {@link ActorProducible}.
 */
public class SpiritGoat extends Creature implements Curable, Rotatable, ActorProducible {

    /**
     * The initial number of turns the Spirit Goat survives with Crimson Rot before becoming
     * unconscious. This is also the value the timer resets to when cured.
     */
    public static final int INITIAL_ROT_COUNTDOWN = 10;
    /**
     * Display a character representing the Spirit Goat on the game map.
     */
    private final static char DISPLAY_CHAR = 'y';
    /**
     * Initial hit points (health) of the Spirit Goat.
     */
    private final static int HIT_POINTS = 50;
    /**
     * The name of this creature type.
     */
    private final static String NAME = "Spirit Goat";

    /**
     * Tracks the remaining turns before the rot effect expires.
     */
    private int currentRotCountdown;

    /**
     * Priority for the {@link ProduceBehaviour}. Ensures producing offspring is checked before
     * wandering.
     */
    private static final int PRIORITY_PRODUCE = 1;
    /**
     * Priority for the {@link WanderBehaviour}. A lower priority action.
     */
    private static final int PRIORITY_WANDER = 999;


    /**
     * Constructor for the SpiritGoat with default priority behaviour selector. Initializes the goat
     * with its name, display character, hit points and sets the initial rot countdown.
     */
    public SpiritGoat() {
        super(SpiritGoat.NAME, SpiritGoat.DISPLAY_CHAR, SpiritGoat.HIT_POINTS);
        this.currentRotCountdown = this.getInitialRotCountdown(); // Initialize countdown
    }

    /**
     * Constructor with custom behaviour selector.
     *
     * @param behaviourSelector the strategy for selecting behaviours
     */
    public SpiritGoat(BehaviourSelector behaviourSelector) {
        super(SpiritGoat.NAME, SpiritGoat.DISPLAY_CHAR, SpiritGoat.HIT_POINTS, behaviourSelector);
        this.currentRotCountdown = this.getInitialRotCountdown();
    }

    /**
     * Initialize the behaviours for Spirit Goat. Priority order: Reproduce -> Wander
     */
    @Override
    protected void initializeBehaviours() {
        this.addBehaviour(PRIORITY_PRODUCE, new ProduceBehaviour(this));
        this.addBehaviour(PRIORITY_WANDER, new WanderBehaviour());
    }

    /**
     * Selects and performs an action for the current turn. First, ticks the internal rot countdown.
     * If the goat becomes unconscious due to rot, it does nothing further. Otherwise, it selects an
     * action based on its behaviours (e.g., WanderBehaviour, ProduceBehaviour).
     *
     * @param actions    Collection of possible Actions for this Actor (potentially generated by
     *                   behaviours).
     * @param lastAction The Action this Actor took last turn.
     * @param map        The map containing the Actor.
     * @param display    The I/O object to which messages may be written.
     * @return The Action to be performed, or {@link DoNothingAction} if unconscious.
     */
    @Override
    public Action playTurn(ActionList actions, Action lastAction, GameMap map, Display display) {
        // Tick the internal rot countdown first
        this.tickRotCountdown(map);

        // If the goat became unconscious due to rot, don't get another action
        if (this.isRotExpired()) {
            return new DoNothingAction(); // Actor is unconscious, cannot act
        }

        return super.playTurn(actions, lastAction, map, display);
    }

    /**
     * Returns a list of actions that the {@code otherActor} can perform on this SpiritGoat. Allows
     * {@link AttackAction} if the {@code otherActor} has the
     * {@link GeneralCapability#HOSTILE_TO_ENEMY} capability. Allows {@link CureAction} if the
     * {@code otherActor} is carrying an item with the {@link GeneralCapability#CAN_CURED}
     * capability and this SpiritGoat's rot timer has not expired yet.
     *
     * @param otherActor The actor that might be performing an action.
     * @param direction  String representing the direction of the other Actor (not used in current
     *                   logic but available).
     * @param map        The current GameMap.
     * @return An {@link ActionList} containing allowable actions.
     */
    @Override
    public ActionList allowableActions(Actor otherActor, String direction, GameMap map) {
        ActionList actions = super.allowableActions(otherActor, direction,
                map); // Include default allowable actions if any

        // Allow cure if the other actor has a curable item and the goat's rot is still active
        if (!this.isRotExpired()) { // Check if the rot timer is still running
            for (Item item : otherActor.getItemInventory()) {
                if (item.hasCapability(GeneralCapability.CAN_CURED)) {
                    // CureAction targets this goat at its current location
                    actions.add(new CureAction(this, map.locationOf(this), item));
                    // break; // Optional: If only one cure item should grant the action
                }
            }
        }

        // Allow attack if the other actor is hostile
        if (otherActor.hasCapability(GeneralCapability.HOSTILE_TO_ENEMY)) {
            actions.add(new AttackAction(this, direction));
        }
        return actions;
    }

    /**
     * Defines the action taken when this Spirit Goat is cured. It resets the internal rot countdown
     * timer back to its initial value ({@value #INITIAL_ROT_COUNTDOWN}). Implements the
     * {@link Curable#cure(Actor, Location, Item)} method.
     *
     * @param healer       The actor performing the cure.
     * @param cureLocation The location where the cure is happening (the Spirit Goat's location).
     * @param healingItem  The item used for healing.
     * @return A string describing the outcome, indicating the timer has been reset.
     */
    @Override
    public String cure(Actor healer, Location cureLocation, Item healingItem) {
        this.resetRotCountdown(); // Reset the internal timer
        return healer + " cures the " + this + " at " + cureLocation + " using " + healingItem
                + ". Rot timer reset to " + this.currentRotCountdown + ".";
    }

    /**
     * Gets the stamina cost required to cure this Spirit Goat. According to game requirements,
     * curing a Spirit Goat costs no stamina. Implements the {@link Curable#getCureStaminaCost()}
     * method.
     *
     * @return Always 0, as no stamina cost is required.
     */
    @Override
    public int getCureStaminaCost() {
        return 0; // No stamina cost to cure this creature
    }

    /**
     * Decrements the internal rot countdown timer by one each turn. If the countdown reaches zero
     * or less ({@link #isRotExpired()} becomes true), it triggers the goat's unconscious state
     * using {@link #unconscious(GameMap)}. Prints the remaining time to the console (optional).
     * Implements the {@link Rotatable#tickRotCountdown(GameMap)} method.
     *
     * @param map The {@link GameMap} the goat is currently on.
     */
    @Override
    public void tickRotCountdown(GameMap map) {
        if (currentRotCountdown > 0) {
            currentRotCountdown--;
            if (isRotExpired()) {
                // Handle expiry - make the actor unconscious
                this.unconscious(map); // Call the existing unconscious method inherited from Actor
            }
        }
    }

    /**
     * Resets the rot countdown timer back to its initial value ({@value #INITIAL_ROT_COUNTDOWN}).
     * Implements the {@link Rotatable#resetRotCountdown()} method.
     */
    @Override
    public void resetRotCountdown() {
        this.currentRotCountdown = this.getInitialRotCountdown();
    }

    /**
     * Checks if the rot countdown timer has reached zero or less. Implements the
     * {@link Rotatable#isRotExpired()} method.
     *
     * @return {@code true} if the countdown is less than or equal to 0, {@code false} otherwise.
     */
    @Override
    public boolean isRotExpired() {
        return currentRotCountdown <= 0;
    }

    /**
     * Gets the initial duration (in turns) for the rot countdown for Spirit Goats. Implements the
     * {@link Rotatable#getInitialRotCountdown()} method.
     *
     * @return The initial countdown value ({@value #INITIAL_ROT_COUNTDOWN}).
     */
    @Override
    public int getInitialRotCountdown() {
        return SpiritGoat.INITIAL_ROT_COUNTDOWN;
    }

    /**
     * Gets the current remaining turns on the rot countdown. Implements the
     * {@link Rotatable#getCurrentRotCountdown()} method.
     *
     * @return The current value of {@code currentRotCountdown}.
     */
    @Override
    public int getCurrentRotCountdown() {
        return this.currentRotCountdown;
    }

    /**
     * Checks if the Spirit Goat can produce offspring. Production is possible if there is an entity
     * with the {@link GeneralCapability#BLESSED} capability at the Spirit Goat's current location
     * or any adjacent location.
     *
     * @param producer The Spirit Goat (this instance).
     * @param map      The game map.
     * @return true if a blessed entity is nearby, false otherwise.
     */
    @Override
    public boolean canProduceOffspring(Actor producer, GameMap map) {
        Condition nearbyBlessed = new NearbyCapabilityCondition(map.locationOf(this),
                GeneralCapability.BLESSED);
        return nearbyBlessed.check();
    }

    /**
     * Produces a new Spirit Goat. The new goat is placed in an adjacent, enterable location if one
     * exists.
     *
     * @param producer The Spirit Goat (this instance) that is producing.
     * @param map      The game map where the new goat will be placed.
     * @return A string describing the outcome of the production attempt. Returns a success message
     * if a new goat is spawned, or a message indicating no suitable spot was found.
     */
    @Override
    public String produceOffspring(Actor producer, GameMap map) {
        Location producerLocation = map.locationOf(producer);
        Actor newGoat = new SpiritGoat(); // Create a new instance of SpiritGoat
        for (Exit exit : producerLocation.getExits()) {
            Location destination = exit.getDestination();
            // Check if destination is suitable for spawning (can actor enter and no actor already there)
            if (destination.canActorEnter(newGoat) && !map.isAnActorAt(destination)) {
                map.addActor(newGoat, destination); // Add it to the map at the destination
                return producer + " feels the grace and a new Spirit Goat appears nearby at ("
                        + destination.x() + "," + destination.y() + ")!";
            }
        }
        return producer + " feels blessed but cannot find a spot for new life.";
    }
}